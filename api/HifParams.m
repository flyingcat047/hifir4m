function params = HifParams(varargin)
%parseParams - Parse parameters for HIFIR
%
%    params = HifParams
% returns a MATLAB struct containing the default parameters.
%
%    params = HifParams('name1', val1, 'name2', val2, ...)
% returns a MATLAB struct with the specified values along with default
% values for the other fields. The fields and their defaults are:
%
%             tau_L: 1e-04
%             tau_U: 1e-04
%           kappa_d: 3
%             kappa: 3
%           alpha_L: 10
%           alpha_U: 10
%               rho: 0.5
%               c_d: 10
%               c_h: 2
%                 N: -1
%           verbose: 0
%            rf_par: 1
%           reorder: 1
%               spd: 0
%             check: 1
%         pre_scale: 0
%     symm_pre_lvls: 1
%           threads: 0
%         mumps_blr: 1
%     fat_schur_1st: 0
%         rrqr_cond: 0
%             pivot: 0
%             gamma: 1
%              beta: 1000
%           is_symm: 0
%            no_pre: 0
%          is_mixed: 0
%        is_complex: 0
%
% See also hifCreate, hifApply

persistent defaults fields
if isempty(defaults)
    defaults = struct('tau_L', 1e-4, ...
        'tau_U', 1e-4, ...
        'kappa_d', 3.0, ...
        'kappa', 3.0, ...
        'alpha_L', 10, ...
        'alpha_U', 10, ...
        'rho', 0.5, ...
        'c_d', 10.0, ...
        'c_h', 2.0, ...
        'N', -1, ...
        'verbose', 0, ...
        'rf_par', 1, ...
        'reorder', 1, ...
        'spd', 0, ...
        'check', 1, ...
        'pre_scale', 0, ...
        'symm_pre_lvls', 1, ...
        'threads', 0, ...
        'mumps_blr', 1, ...
        'fat_schur_1st', 0, ...
        'rrqr_cond', 0, ...
        'pivot', 2, ...
        'gamma', 1, ...
        'beta', 1e3, ...
        'is_symm', 0, ...
        'no_pre', 0, ...
        'nzp_thres', 0.65, ...
        'dense_thres', 2000, ...
        'is_mixed', 0, ...
        'is_complex', 0);
    fields = fieldnames(defaults);
end

p = inputParser;
positive_params = {'tau_L', 'tau_U', 'kappa_d', 'kappa', 'alpha_L', ...
    'alpha_U', 'rho', 'c_d', 'c_h', 'nzp_thres', 'dense_thres'};
for i = 1:numel(positive_params)
    addParameter(p, positive_params{i}, defaults.(positive_params{i}), ...
        @(x) isscalar(x) && x > 0);
end

nonnegative_params = {'verbose', 'rf_par', 'reorder', 'spd', 'check', ...
    'pre_scale', 'symm_pre_lvls', 'threads', 'mumps_blr', 'fat_schur_1st', ...
    'pivot', 'gamma', 'beta', 'is_symm', 'no_pre', 'is_mixed', 'is_complex'};
for i = 1:numel(nonnegative_params)
    addParameter(p, nonnegative_params{i}, defaults.(nonnegative_params{i}), ...
        @(x) isscalar(x) && x >= 0);
end

addParameter(p, 'N', defaults.N, @isscalar);
addParameter(p, 'rrqr_cond', defaults.rrqr_cond, @isscalar);

p.KeepUnmatched = true;  % This seems needed for Octave
parse(p, varargin{:});
sorted_opts = p.Results;

% Reorder structure
params = struct;
for idx = 1:length(fields)
    params.(fields{idx}) = sorted_opts.(fields{idx});
end
end
